import { Client } from '@notionhq/client';
import type { WeekPlan } from '../types/index.js';
import { today } from '../utils/date.js';

export interface NotionConfig {
  apiKey: string;
  plansDbId: string;
  currentPlanPageId?: string;
}

type PlanStatus = WeekPlan['status'];
type PlanGoal = WeekPlan['goal'];

// Notion property names (must match your database exactly)
const PROPS = {
  title: 'Title',
  planId: 'Plan Id',
  weekStart: 'Week Start',
  status: 'Status',
  goal: 'Goal',
  plan: 'Plan',
  summary: 'Summary',
  plannedLoad: 'Planned Load',
  actualLoad: 'Actual Load',
  generatedByAi: 'Generated By AI',
  lastUpdated: 'Last Updated',
} as const;

export class NotionClient {
  private readonly client: Client;
  private readonly plansDbId: string;
  private readonly currentPlanPageId?: string;

  constructor(config: NotionConfig) {
    this.client = new Client({ auth: config.apiKey });
    this.plansDbId = config.plansDbId;
    this.currentPlanPageId = config.currentPlanPageId;
  }

  async createPlan(plan: Omit<WeekPlan, 'id'>): Promise<WeekPlan> {
    const response = await this.client.pages.create({
      parent: { database_id: this.plansDbId },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      properties: toNotionProps(plan) as any,
    });

    // Update the current plan page if configured
    if (this.currentPlanPageId) {
      await this.updateCurrentPlanPage(plan.title, plan.plan);
    }

    return fromNotionPage(response);
  }

  async updatePlan(id: string, updates: Partial<Omit<WeekPlan, 'id'>>): Promise<WeekPlan> {
    // Update properties
    const response = await this.client.pages.update({
      page_id: id,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      properties: toNotionProps(updates) as any,
    });

    // If plan text changed, update the current plan page
    if (updates.plan && this.currentPlanPageId) {
      await this.updateCurrentPlanPage(updates.title ?? 'Current Plan', updates.plan);
    }

    return fromNotionPage(response);
  }

  async getPlanByPlanId(planId: string): Promise<WeekPlan | null> {
    const response = await this.client.databases.query({
      database_id: this.plansDbId,
      filter: { property: PROPS.planId, rich_text: { equals: planId } },
    });
    return response.results.length > 0 ? fromNotionPage(response.results[0]) : null;
  }

  private async updateCurrentPlanPage(title: string, planText: string): Promise<void> {
    if (!this.currentPlanPageId) return;

    // Get existing blocks
    const existing = await this.client.blocks.children.list({ block_id: this.currentPlanPageId });

    // Delete all existing blocks
    for (const block of existing.results) {
      await this.client.blocks.delete({ block_id: block.id });
    }

    // Add new blocks
    await this.client.blocks.children.append({
      block_id: this.currentPlanPageId,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      children: planToBlocks(title, planText) as any,
    });
  }
}

// Convert WeekPlan to Notion properties
function toNotionProps(plan: Partial<Omit<WeekPlan, 'id'>>): Record<string, unknown> {
  const props: Record<string, unknown> = {};

  const text = (key: string, value?: string) => {
    if (value !== undefined) props[key] = { rich_text: [{ text: { content: value } }] };
  };
  const title = (key: string, value?: string) => {
    if (value !== undefined) props[key] = { title: [{ text: { content: value } }] };
  };
  const date = (key: string, value?: string) => {
    if (value !== undefined) props[key] = { date: { start: value } };
  };
  const select = (key: string, value?: string) => {
    if (value !== undefined) props[key] = { select: { name: value } };
  };
  const num = (key: string, value?: number) => {
    if (value !== undefined) props[key] = { number: value };
  };
  const check = (key: string, value?: boolean) => {
    if (value !== undefined) props[key] = { checkbox: value };
  };

  title(PROPS.title, plan.title);
  text(PROPS.planId, plan.planId);
  date(PROPS.weekStart, plan.weekStart);
  select(PROPS.status, plan.status);
  select(PROPS.goal, plan.goal);
  text(PROPS.plan, plan.plan);
  text(PROPS.summary, plan.summary);
  num(PROPS.plannedLoad, plan.plannedLoad);
  num(PROPS.actualLoad, plan.actualLoad);
  check(PROPS.generatedByAi, plan.generatedByAi);
  date(PROPS.lastUpdated, plan.lastUpdated);

  return props;
}

// Convert plan text to Notion blocks (page content)
function planToBlocks(title: string, planText: string): Array<Record<string, unknown>> {
  const blocks: Array<Record<string, unknown>> = [
    {
      object: 'block',
      type: 'heading_2',
      heading_2: { rich_text: [{ type: 'text', text: { content: title } }] },
    },
  ];

  // Each line becomes a bullet point
  for (const line of planText.split('\n')) {
    if (line.trim()) {
      blocks.push({
        object: 'block',
        type: 'bulleted_list_item',
        bulleted_list_item: { rich_text: [{ type: 'text', text: { content: line } }] },
      });
    }
  }

  return blocks;
}

// Convert Notion page to WeekPlan
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function fromNotionPage(page: any): WeekPlan {
  const p = page.properties;
  return {
    id: page.id,
    title: p[PROPS.title]?.title?.[0]?.text?.content ?? '',
    planId: p[PROPS.planId]?.rich_text?.[0]?.text?.content ?? '',
    weekStart: p[PROPS.weekStart]?.date?.start ?? '',
    status: (p[PROPS.status]?.select?.name ?? 'Planned') as PlanStatus,
    goal: (p[PROPS.goal]?.select?.name ?? 'Build Fitness') as PlanGoal,
    plan: p[PROPS.plan]?.rich_text?.[0]?.text?.content ?? '',
    summary: p[PROPS.summary]?.rich_text?.[0]?.text?.content || undefined,
    plannedLoad: p[PROPS.plannedLoad]?.number ?? undefined,
    actualLoad: p[PROPS.actualLoad]?.number ?? undefined,
    generatedByAi: p[PROPS.generatedByAi]?.checkbox ?? false,
    lastUpdated: p[PROPS.lastUpdated]?.date?.start ?? today(),
  };
}
